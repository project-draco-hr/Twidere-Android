{
  final int action=event.getAction();
  final boolean handled=true;
  if (!mGestureInProgress) {
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_POINTER_DOWN:
{
        final DisplayMetrics metrics=mContext.getResources().getDisplayMetrics();
        mRightSlopEdge=metrics.widthPixels - mEdgeSlop;
        mBottomSlopEdge=metrics.heightPixels - mEdgeSlop;
        reset();
        mPrevEvent=MotionEvent.obtain(event);
        mTimeDelta=0;
        setContext(event);
        final float edgeSlop=mEdgeSlop;
        final float rightSlop=mRightSlopEdge;
        final float bottomSlop=mBottomSlopEdge;
        final float x0=event.getRawX();
        final float y0=event.getRawY();
        final float x1=getRawX(event,1);
        final float y1=getRawY(event,1);
        final boolean p0sloppy=x0 < edgeSlop || y0 < edgeSlop || x0 > rightSlop || y0 > bottomSlop;
        final boolean p1sloppy=x1 < edgeSlop || y1 < edgeSlop || x1 > rightSlop || y1 > bottomSlop;
        if (p0sloppy && p1sloppy) {
          mFocusX=-1;
          mFocusY=-1;
          mSloppyGesture=true;
        }
 else         if (p0sloppy) {
          mFocusX=MotionEventCompat.getX(event,1);
          mFocusY=MotionEventCompat.getY(event,1);
          mSloppyGesture=true;
        }
 else         if (p1sloppy) {
          mFocusX=MotionEventCompat.getX(event,0);
          mFocusY=MotionEventCompat.getY(event,0);
          mSloppyGesture=true;
        }
 else {
          mGestureInProgress=mListener.onScaleBegin(this);
        }
      }
    break;
case MotionEvent.ACTION_MOVE:
  if (mSloppyGesture) {
    final float edgeSlop=mEdgeSlop;
    final float rightSlop=mRightSlopEdge;
    final float bottomSlop=mBottomSlopEdge;
    final float x0=event.getRawX();
    final float y0=event.getRawY();
    final float x1=getRawX(event,1);
    final float y1=getRawY(event,1);
    final boolean p0sloppy=x0 < edgeSlop || y0 < edgeSlop || x0 > rightSlop || y0 > bottomSlop;
    final boolean p1sloppy=x1 < edgeSlop || y1 < edgeSlop || x1 > rightSlop || y1 > bottomSlop;
    if (p0sloppy && p1sloppy) {
      mFocusX=-1;
      mFocusY=-1;
    }
 else     if (p0sloppy) {
      mFocusX=MotionEventCompat.getX(event,1);
      mFocusY=MotionEventCompat.getY(event,1);
    }
 else     if (p1sloppy) {
      mFocusX=MotionEventCompat.getX(event,0);
      mFocusY=MotionEventCompat.getY(event,0);
    }
 else {
      mSloppyGesture=false;
      mGestureInProgress=mListener.onScaleBegin(this);
    }
  }
break;
case MotionEvent.ACTION_POINTER_UP:
if (mSloppyGesture) {
final int id=(action & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT == 0 ? 1 : 0;
mFocusX=event.getX(id);
mFocusY=event.getY(id);
}
break;
}
}
 else {
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_POINTER_UP:
setContext(event);
final int id=(action & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT == 0 ? 1 : 0;
mFocusX=event.getX(id);
mFocusY=event.getY(id);
if (!mSloppyGesture) {
mListener.onScaleEnd(this);
}
reset();
break;
case MotionEvent.ACTION_CANCEL:
if (!mSloppyGesture) {
mListener.onScaleEnd(this);
}
reset();
break;
case MotionEvent.ACTION_MOVE:
setContext(event);
if (mCurrPressure / mPrevPressure > PRESSURE_THRESHOLD) {
final boolean updatePrevious=mListener.onScale(this);
if (updatePrevious) {
mPrevEvent.recycle();
mPrevEvent=MotionEvent.obtain(event);
}
}
break;
}
}
return handled;
}
