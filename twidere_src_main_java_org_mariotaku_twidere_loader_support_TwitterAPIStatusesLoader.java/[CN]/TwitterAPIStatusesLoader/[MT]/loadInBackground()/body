{
  final File serializationFile=getSerializationFile();
  final List<ParcelableStatus> data=getData();
  if (isFirstLoad() && getTabPosition() >= 0 && serializationFile != null) {
    final List<ParcelableStatus> cached=getCachedData(serializationFile);
    if (cached != null) {
      data.addAll(cached);
      if (mComparator != null) {
        Collections.sort(data,mComparator);
      }
 else {
        Collections.sort(data);
      }
      return new CopyOnWriteArrayList<>(data);
    }
  }
  if (!isFromUser())   return data;
  final Twitter twitter=getTwitter();
  if (twitter == null)   return null;
  final List<Status> statuses;
  final boolean truncated;
  final Context context=getContext();
  final SharedPreferences prefs=context.getSharedPreferences(SHARED_PREFERENCES_NAME,Context.MODE_PRIVATE);
  final int loadItemLimit=prefs.getInt(KEY_LOAD_ITEM_LIMIT,DEFAULT_LOAD_ITEM_LIMIT);
  final boolean noItemsBefore=data == null || data.isEmpty();
  try {
    final Paging paging=new Paging();
    paging.setCount(loadItemLimit);
    if (mMaxId > 0) {
      paging.setMaxId(mMaxId);
    }
    if (mSinceId > 0) {
      paging.setSinceId(mSinceId - 1);
    }
    statuses=new ArrayList<>();
    truncated=truncateStatuses(getStatuses(twitter,paging),statuses,mSinceId);
  }
 catch (  final TwitterException e) {
    Log.w(LOGTAG,e);
    return new CopyOnWriteArrayList<>(data);
  }
  final long[] statusIds=new long[statuses.size()];
  long minId=-1;
  int minIdx=-1;
  int rowsDeleted=0;
  for (int i=0, j=statuses.size(); i < j; i++) {
    final Status status=statuses.get(i);
    final long id=status.getId();
    if (minId == -1 || id < minId) {
      minId=id;
      minIdx=i;
    }
    statusIds[i]=id;
    if (deleteStatus(data,status.getId())) {
      rowsDeleted++;
    }
  }
  final boolean deletedOldGap=rowsDeleted > 0 && ArrayUtils.contains(statusIds,mMaxId);
  final boolean noRowsDeleted=rowsDeleted == 0;
  final boolean insertGap=minId > 0 && (noRowsDeleted || deletedOldGap) && !truncated && !noItemsBefore && statuses.size() > 1;
  for (int i=0, j=statuses.size(); i < j; i++) {
    final Status status=statuses.get(i);
    data.add(new ParcelableStatus(status,mAccountId,insertGap && isGapEnabled() && minIdx == i));
  }
  final SQLiteDatabase db=TwidereApplication.getInstance(context).getSQLiteDatabase();
  final ParcelableStatus[] array=data.toArray(new ParcelableStatus[data.size()]);
  for (int i=0, size=array.length; i < size; i++) {
    final ParcelableStatus status=array[i];
    if (shouldFilterStatus(db,status) && !status.is_gap && i != size - 1) {
      deleteStatus(data,status.id);
    }
  }
  if (mComparator != null) {
    Collections.sort(data,mComparator);
  }
 else {
    Collections.sort(data);
  }
  saveCachedData(serializationFile,data);
  return new CopyOnWriteArrayList<>(data);
}
