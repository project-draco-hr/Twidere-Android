{
  if (!ApiHelper.HAS_REUSING_BITMAP_IN_BITMAP_REGION_DECODER)   return getTileWithoutReusingBitmap(level,x,y,tileSize,borderSize);
  final int b=borderSize << level;
  final int t=tileSize << level;
  final Rect wantRegion=new Rect(x - b,y - b,x + t + b,y + t + b);
  boolean needClear;
  BitmapRegionDecoder regionDecoder=null;
synchronized (this) {
    regionDecoder=mRegionDecoder;
    if (regionDecoder == null)     return null;
    needClear=!new Rect(0,0,mImageWidth,mImageHeight).contains(wantRegion);
  }
  Bitmap bitmap=pool == null ? null : pool.getBitmap();
  if (bitmap != null) {
    if (needClear) {
      bitmap.eraseColor(0);
    }
  }
 else {
    final int s=tileSize + 2 * borderSize;
    bitmap=Bitmap.createBitmap(s,s,Config.RGB_565);
  }
  final BitmapFactory.Options options=new BitmapFactory.Options();
  options.inPreferredConfig=Config.RGB_565;
  options.inPreferQualityOverSpeed=true;
  options.inSampleSize=1 << level;
  options.inBitmap=bitmap;
  try {
synchronized (regionDecoder) {
      bitmap=regionDecoder.decodeRegion(wantRegion,options);
    }
  }
  finally {
    if (options.inBitmap != bitmap && options.inBitmap != null) {
      if (pool != null) {
        pool.recycle(options.inBitmap);
      }
      options.inBitmap=null;
    }
  }
  if (bitmap == null) {
    Log.w(TAG,"fail in decoding region");
  }
  return bitmap;
}
