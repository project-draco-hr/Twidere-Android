{
  if (clusters.equals(StatusClusterRenderer.this.mClusters)) {
    mCallback.run();
    return;
  }
  final MarkerModifier markerModifier=new MarkerModifier();
  final float zoom=mMapZoom;
  final boolean zoomingIn=zoom > mZoom;
  final float zoomDelta=zoom - mZoom;
  final Set<MarkerWithPosition> markersToRemove=mMarkers;
  final LatLngBounds visibleBounds=mProjection.getVisibleRegion().latLngBounds;
  List<Point> existingClustersOnScreen=null;
  if (StatusClusterRenderer.this.mClusters != null && SHOULD_ANIMATE) {
    existingClustersOnScreen=new ArrayList<>();
    for (    Cluster<ClusterStatus> c : StatusClusterRenderer.this.mClusters) {
      if (shouldRenderAsCluster(c) && visibleBounds.contains(c.getPosition())) {
        Point point=mSphericalMercatorProjection.toPoint(c.getPosition());
        existingClustersOnScreen.add(point);
      }
    }
  }
  final Set<MarkerWithPosition> newMarkers=Collections.newSetFromMap(new ConcurrentHashMap<MarkerWithPosition,Boolean>());
  for (  Cluster<ClusterStatus> c : clusters) {
    boolean onScreen=visibleBounds.contains(c.getPosition());
    if (zoomingIn && onScreen && SHOULD_ANIMATE) {
      Point point=mSphericalMercatorProjection.toPoint(c.getPosition());
      Point closest=findClosestCluster(existingClustersOnScreen,point);
      if (closest != null) {
        LatLng animateTo=mSphericalMercatorProjection.toLatLng(closest);
        markerModifier.add(true,new CreateMarkerTask(c,newMarkers,animateTo));
      }
 else {
        markerModifier.add(true,new CreateMarkerTask(c,newMarkers,null));
      }
    }
 else {
      markerModifier.add(onScreen,new CreateMarkerTask(c,newMarkers,null));
    }
  }
  markerModifier.waitUntilFree();
  markersToRemove.removeAll(newMarkers);
  List<Point> newClustersOnScreen=null;
  if (SHOULD_ANIMATE) {
    newClustersOnScreen=new ArrayList<>();
    for (    Cluster<ClusterStatus> c : clusters) {
      if (shouldRenderAsCluster(c) && visibleBounds.contains(c.getPosition())) {
        Point p=mSphericalMercatorProjection.toPoint(c.getPosition());
        newClustersOnScreen.add(p);
      }
    }
  }
  for (  final MarkerWithPosition marker : markersToRemove) {
    boolean onScreen=visibleBounds.contains(marker.position);
    if (!zoomingIn && zoomDelta > -3 && onScreen && SHOULD_ANIMATE) {
      final Point point=mSphericalMercatorProjection.toPoint(marker.position);
      final Point closest=findClosestCluster(newClustersOnScreen,point);
      if (closest != null) {
        LatLng animateTo=mSphericalMercatorProjection.toLatLng(closest);
        markerModifier.animateThenRemove(marker,marker.position,animateTo);
      }
 else {
        markerModifier.remove(true,marker.marker);
      }
    }
 else {
      markerModifier.remove(onScreen,marker.marker);
    }
  }
  markerModifier.waitUntilFree();
  mMarkers=newMarkers;
  StatusClusterRenderer.this.mClusters=clusters;
  mZoom=zoom;
  mCallback.run();
}
