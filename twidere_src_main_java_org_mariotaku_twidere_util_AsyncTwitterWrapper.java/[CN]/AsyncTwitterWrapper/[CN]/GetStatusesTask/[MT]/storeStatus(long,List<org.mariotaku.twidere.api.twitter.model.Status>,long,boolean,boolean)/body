{
  if (statuses == null || statuses.isEmpty() || accountId <= 0) {
    return;
  }
  final Uri uri=getDatabaseUri();
  final boolean noItemsBefore=Utils.getStatusCountInDatabase(mContext,uri,accountId) <= 0;
  final ContentValues[] values=new ContentValues[statuses.size()];
  final long[] statusIds=new long[statuses.size()];
  long minId=-1;
  int minIdx=-1;
  for (int i=0, j=statuses.size(); i < j; i++) {
    final org.mariotaku.twidere.api.twitter.model.Status status=statuses.get(i);
    values[i]=ContentValuesCreator.createStatus(status,accountId);
    final long id=status.getId();
    if (minId == -1 || id < minId) {
      minId=id;
      minIdx=i;
    }
    statusIds[i]=id;
  }
  final Expression accountWhere=Expression.equals(Statuses.ACCOUNT_ID,accountId);
  final Expression statusWhere=Expression.in(new Column(Statuses.STATUS_ID),new RawItemArray(statusIds));
  final String countWhere=Expression.and(accountWhere,statusWhere).getSQL();
  final String[] projection={SQLFunctions.COUNT()};
  final int rowsDeleted;
  final Cursor countCur=mResolver.query(uri,projection,countWhere,null,null);
  try {
    if (countCur != null && countCur.moveToFirst()) {
      rowsDeleted=countCur.getInt(0);
    }
 else {
      rowsDeleted=0;
    }
  }
  finally {
    Utils.closeSilently(countCur);
  }
  final RefreshEvent event=RefreshEvent.create(mContext,statusIds,getTimelineType());
  HotMobiLogger.getInstance(mContext).log(accountId,event);
  final boolean deletedOldGap=rowsDeleted > 0 && ArrayUtils.contains(statusIds,maxId);
  final boolean noRowsDeleted=rowsDeleted == 0;
  final boolean insertGap=minId > 0 && (noRowsDeleted || deletedOldGap) && !truncated && !noItemsBefore && statuses.size() > 1;
  if (insertGap && minIdx != -1) {
    values[minIdx].put(Statuses.IS_GAP,true);
  }
  final Uri insertUri=UriUtils.appendQueryParameters(uri,QUERY_PARAM_NOTIFY,notify);
  ContentResolverUtils.bulkInsert(mResolver,insertUri,values);
}
