{
  final List<ActivityListResponse> result=new ArrayList<>();
  if (mAccountIds == null)   return result;
  int idx=0;
  final int loadItemLimit=mPreferences.getInt(KEY_LOAD_ITEM_LIMIT,DEFAULT_LOAD_ITEM_LIMIT);
  for (  final long accountId : mAccountIds) {
    final Twitter twitter=TwitterAPIFactory.getTwitterInstance(mContext,accountId,true);
    if (twitter == null)     continue;
    try {
      final Paging paging=new Paging();
      paging.count(loadItemLimit);
      final long maxId, sinceId;
      if (isMaxIdsValid() && mMaxIds[idx] > 0) {
        maxId=mMaxIds[idx];
        paging.maxId(maxId);
      }
 else {
        maxId=-1;
      }
      if (isSinceIdsValid() && mSinceIds[idx] > 0) {
        sinceId=mSinceIds[idx];
        paging.sinceId(sinceId - 1);
      }
 else {
        sinceId=-1;
      }
      final List<Activity> activities=new ArrayList<>();
      final boolean truncated=Utils.truncateActivities(getActivities(twitter,paging),activities,sinceId);
      final Pair<Long,Long> positions;
      if (activities.isEmpty()) {
        positions=new Pair<>(-1L,-1L);
      }
 else {
        final Activity minActivity=Collections.min(activities);
        positions=new Pair<>(minActivity.getMinPosition(),minActivity.getMaxPosition());
      }
      storeStatus(accountId,activities,positions,truncated,true);
      publishProgress(new ActivityListResponse(accountId,activities));
    }
 catch (    final TwitterException e) {
      Log.w(LOGTAG,e);
      result.add(new ActivityListResponse(accountId,e));
    }
    idx++;
  }
  return result;
}
