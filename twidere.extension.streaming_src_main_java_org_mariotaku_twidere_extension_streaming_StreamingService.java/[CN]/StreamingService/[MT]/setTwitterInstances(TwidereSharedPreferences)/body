{
  if (prefs == null)   return false;
  final List<ParcelableCredentials> accountsList=ParcelableAccount.getCredentialsList(this,true);
  if (BuildConfig.DEBUG) {
    Log.d(LOGTAG,"Setting up twitter stream instances");
  }
  mAccountIds=new long[accountsList.size()];
  clearTwitterInstances();
  for (int i=0, j=accountsList.size(); i < j; i++) {
    final ParcelableCredentials account=accountsList.get(i);
    final String token=account.oauth_token;
    final String secret=account.oauth_token_secret;
    final long account_id=account.account_id;
    mAccountIds[i]=account_id;
    final StreamConfigurationBuilder cb=new StreamConfigurationBuilder();
    cb.setGZIPEnabled(prefs.getBoolean(KEY_GZIP_COMPRESSING,true));
    cb.setIncludeEntitiesEnabled(true);
    if (prefs.getBoolean(KEY_IGNORE_SSL_ERROR,false)) {
      cb.setIgnoreSSLError(true);
      cb.setHostAddressResolverFactory(new TwidereHostAddressResolverFactory(this));
    }
    final String default_consumer_key=Utils.getNonEmptyString(prefs,KEY_CONSUMER_KEY,TWITTER_CONSUMER_KEY_2);
    final String default_consumer_secret=Utils.getNonEmptyString(prefs,KEY_CONSUMER_SECRET,TWITTER_CONSUMER_SECRET_2);
    final String consumer_key=account.consumer_key, consumer_secret=account.consumer_secret;
    if (!isEmpty(consumer_key) && !isEmpty(consumer_secret)) {
      cb.setOAuthConsumerKey(consumer_key);
      cb.setOAuthConsumerSecret(consumer_secret);
    }
 else {
      cb.setOAuthConsumerKey(default_consumer_key);
      cb.setOAuthConsumerSecret(default_consumer_secret);
    }
    final TwitterStream twitter=new TwitterStreamFactory(cb.build()).getInstance(new AccessToken(token,secret));
    twitter.addListener(new UserStreamListenerImpl(this,account_id));
    twitter.user();
    mTwitterInstances.add(new WeakReference<>(twitter));
  }
  return true;
}
