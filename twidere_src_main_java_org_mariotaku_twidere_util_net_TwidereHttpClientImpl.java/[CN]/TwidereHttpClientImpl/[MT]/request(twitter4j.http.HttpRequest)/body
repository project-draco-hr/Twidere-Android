{
  final HostAddressResolver resolver=FactoryUtils.getHostAddressResolver(conf);
  final String urlString=req.getURL();
  final URI urlOrig=ParseUtils.parseURI(urlString);
  final String host=urlOrig.getHost(), authority=urlOrig.getAuthority();
  try {
    HttpRequestBaseHC4 commonsRequest;
    final String resolvedHost=resolver != null ? resolver.resolve(host) : null;
    final String resolvedUrl=!isEmpty(resolvedHost) ? urlString.replace("://" + host,"://" + resolvedHost) : urlString;
    final RequestMethod method=req.getMethod();
    if (method == RequestMethod.GET) {
      commonsRequest=new HttpGetHC4(resolvedUrl);
    }
 else     if (method == RequestMethod.POST) {
      final HttpPostHC4 post=new HttpPostHC4(resolvedUrl);
      post.setEntity(getAsEntity(req.getParameters()));
      post.getParams().setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE,false);
      commonsRequest=post;
    }
 else     if (method == RequestMethod.DELETE) {
      commonsRequest=new HttpDeleteHC4(resolvedUrl);
    }
 else     if (method == RequestMethod.HEAD) {
      commonsRequest=new HttpHeadHC4(resolvedUrl);
    }
 else     if (method == RequestMethod.PUT) {
      final HttpPutHC4 put=new HttpPutHC4(resolvedUrl);
      put.setEntity(getAsEntity(req.getParameters()));
      commonsRequest=put;
    }
 else     throw new TwitterException("Unsupported request method " + method);
    final HttpParams httpParams=commonsRequest.getParams();
    HttpClientParams.setRedirecting(httpParams,false);
    final Map<String,String> headers=req.getRequestHeaders();
    for (    final String headerName : headers.keySet()) {
      commonsRequest.addHeader(headerName,headers.get(headerName));
    }
    final Authorization authorization=req.getAuthorization();
    final String authorizationHeader=authorization != null ? authorization.getAuthorizationHeader(req) : null;
    if (authorizationHeader != null) {
      commonsRequest.addHeader(HttpHeaders.AUTHORIZATION,authorizationHeader);
    }
    if (resolvedHost != null && !resolvedHost.isEmpty() && !resolvedHost.equals(host)) {
      commonsRequest.addHeader(HttpHeaders.HOST,authority);
    }
    final ApacheHttpClientHttpResponseImpl res;
    try {
      final HttpContext httpContext=new BasicHttpContextHC4();
      httpContext.setAttribute(HostResolvedSSLConnectionSocketFactory.HTTP_CONTEXT_KEY_ORIGINAL_HOST,host);
      res=new ApacheHttpClientHttpResponseImpl(client.execute(commonsRequest,httpContext),conf);
    }
 catch (    final IllegalStateException e) {
      throw new TwitterException("Please check your API settings.",e);
    }
catch (    final NullPointerException e) {
      throw new TwitterException("Please check your APN settings, make sure not to use WAP APNs.",e);
    }
catch (    final OutOfMemoryError e) {
      System.gc();
      throw new TwitterException("Unknown error",e);
    }
    final int statusCode=res.getStatusCode();
    if (statusCode < OK || statusCode > ACCEPTED)     throw new TwitterException(res.asString(),req,res);
    return res;
  }
 catch (  final IOException e) {
    if (resolver instanceof TwidereHostAddressResolver) {
      final TwidereHostAddressResolver twidereResolver=(TwidereHostAddressResolver)resolver;
      twidereResolver.removeCachedHost(host);
    }
    throw new TwitterException(e);
  }
}
