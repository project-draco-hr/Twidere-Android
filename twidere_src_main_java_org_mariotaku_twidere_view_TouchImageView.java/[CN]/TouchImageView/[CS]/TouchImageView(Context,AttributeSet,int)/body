{
  super(context,attrs,defStyle);
  final TouchGestureDetector.OnTouchGestureListener listener=new TouchGestureDetector.OnTouchGestureListener(){
    @Override public boolean onSingleTapConfirmed(    MotionEvent e){
      return performClick();
    }
    @Override public void onLongPress(    MotionEvent e){
      performLongClick();
    }
    @Override public boolean onDoubleTap(    MotionEvent e){
      loadMatrixValues();
      final float minScale=getMinScale();
      final boolean shouldZoomOut=mScale > minScale;
      final float targetScale=shouldZoomOut ? minScale : mMaxScale;
      final float desiredTranslationX=e.getX() - (e.getX() - mTranslationX) * (targetScale / mScale);
      final float desiredTranslationY=e.getY() - (e.getY() - mTranslationY) * (targetScale / mScale);
      final float targetTranslationX=desiredTranslationX + computeTranslation(getMeasuredWidth(),mDrawableIntrinsicWidth * targetScale,desiredTranslationX,0);
      final float targetTranslationY=desiredTranslationY + computeTranslation(getMeasuredHeight(),mDrawableIntrinsicHeight * targetScale,desiredTranslationY,0);
      clearAnimation();
      final Animation animation=new TouchAnimation(targetScale,targetTranslationX,targetTranslationY);
      animation.setDuration(DOUBLE_TAP_ANIMATION_DURATION);
      startAnimation(animation);
      if (mZoomListener != null) {
        if (shouldZoomOut) {
          mZoomListener.onZoomOut();
        }
 else {
          mZoomListener.onZoomIn();
        }
      }
      return true;
    }
    @Override public boolean onScroll(    MotionEvent e1,    MotionEvent e2,    float distanceX,    float distanceY){
      if (mIsAnimatingBack) {
        return false;
      }
      loadMatrixValues();
      final float currentDrawableWidth=mDrawableIntrinsicWidth * mScale;
      final float currentDrawableHeight=mDrawableIntrinsicHeight * mScale;
      final float dx=computeTranslation(getMeasuredWidth(),currentDrawableWidth,mTranslationX,-distanceX);
      final float dy=computeTranslation(getMeasuredHeight(),currentDrawableHeight,mTranslationY,-distanceY);
      mMatrix.postTranslate(dx,dy);
      clearAnimation();
      ViewCompat.postInvalidateOnAnimation(TouchImageView.this);
      return true;
    }
    @Override public boolean onFling(    MotionEvent e1,    MotionEvent e2,    float velocityX,    float velocityY){
      if (mIsAnimatingBack) {
        return false;
      }
      loadMatrixValues();
      final float horizontalSideFreeSpace=(getMeasuredWidth() - mDrawableIntrinsicWidth * mScale) / 2F;
      final float minTranslationX=horizontalSideFreeSpace > 0 ? horizontalSideFreeSpace : getMeasuredWidth() - mDrawableIntrinsicWidth * mScale;
      final float maxTranslationX=horizontalSideFreeSpace > 0 ? horizontalSideFreeSpace : 0;
      final float verticalSideFreeSpace=(getMeasuredHeight() - mDrawableIntrinsicHeight * mScale) / 2F;
      final float minTranslationY=verticalSideFreeSpace > 0 ? verticalSideFreeSpace : getMeasuredHeight() - mDrawableIntrinsicHeight * mScale;
      final float maxTranslationY=verticalSideFreeSpace > 0 ? verticalSideFreeSpace : 0;
      mFlingScroller.fling(Math.round(mTranslationX),Math.round(mTranslationY),Math.round(velocityX),Math.round(velocityY),Math.round(minTranslationX),Math.round(maxTranslationX),Math.round(minTranslationY),Math.round(maxTranslationY));
      clearAnimation();
      final Animation animation=new FlingAnimation();
      animation.setDuration(mFlingScroller.getDuration());
      animation.setInterpolator(new LinearInterpolator());
      startAnimation(animation);
      return true;
    }
    @Override public boolean onScaleBegin(    ScaleGestureDetector detector){
      mLastFocusX=null;
      mLastFocusY=null;
      return true;
    }
    @Override public boolean onScale(    ScaleGestureDetector detector){
      loadMatrixValues();
      float currentDrawableWidth=mDrawableIntrinsicWidth * mScale;
      float currentDrawableHeight=mDrawableIntrinsicHeight * mScale;
      final float focusX=computeFocus(getMeasuredWidth(),currentDrawableWidth,mTranslationX,detector.getFocusX());
      final float focusY=computeFocus(getMeasuredHeight(),currentDrawableHeight,mTranslationY,detector.getFocusY());
      if (mLastFocusX != null && mLastFocusY != null) {
        final float dx=computeScaleTranslation(getMeasuredWidth(),currentDrawableWidth,mTranslationX,focusX - mLastFocusX);
        final float dy=computeScaleTranslation(getMeasuredHeight(),currentDrawableHeight,mTranslationY,focusY - mLastFocusY);
        if (dx != 0 || dy != 0) {
          mMatrix.postTranslate(dx,dy);
        }
      }
      final float scale=computeScale(getMinScale(),mMaxScale,mScale,detector.getScaleFactor());
      mMatrix.postScale(scale,scale,focusX,focusY);
      mLastFocusX=focusX;
      mLastFocusY=focusY;
      clearAnimation();
      ViewCompat.postInvalidateOnAnimation(TouchImageView.this);
      return true;
    }
    @Override public void onScaleEnd(    ScaleGestureDetector detector){
      loadMatrixValues();
      final float currentDrawableWidth=mDrawableIntrinsicWidth * mScale;
      final float currentDrawableHeight=mDrawableIntrinsicHeight * mScale;
      final float dx=computeTranslation(getMeasuredWidth(),currentDrawableWidth,mTranslationX,0);
      final float dy=computeTranslation(getMeasuredHeight(),currentDrawableHeight,mTranslationY,0);
      if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
        return;
      }
      final float targetTranslationX=mTranslationX + dx;
      final float targetTranslationY=mTranslationY + dy;
      clearAnimation();
      final Animation animation=new TouchAnimation(mScale,targetTranslationX,targetTranslationY);
      animation.setDuration(SCALE_END_ANIMATION_DURATION);
      startAnimation(animation);
      mIsAnimatingBack=true;
    }
  }
;
  mTouchGestureDetector=new TouchGestureDetector(context,listener);
  super.setScaleType(ScaleType.MATRIX);
}
