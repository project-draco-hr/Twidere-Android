{
  final String key=getSerializationKey();
  if (key == null || data == null)   return;
  final int databaseItemLimit=mPreferences.getInt(KEY_DATABASE_ITEM_LIMIT,DEFAULT_DATABASE_ITEM_LIMIT);
  try {
    final List<ParcelableStatus> statuses=data.subList(0,Math.min(databaseItemLimit,data.size()));
    final PipedOutputStream pos=new PipedOutputStream();
    final PipedInputStream pis=new PipedInputStream(pos);
    final Future<Object> future=pool.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        LoganSquareMapperFinder.mapperFor(ParcelableStatus.class).serialize(statuses,pos);
        return null;
      }
    }
);
    final boolean saved=mFileCache.save(key,pis,new IoUtils.CopyListener(){
      @Override public boolean onBytesCopied(      int current,      int total){
        return !future.isDone();
      }
    }
);
    if (BuildConfig.DEBUG) {
      Log.v(LOGTAG,key + " saved: " + saved);
    }
  }
 catch (  final Exception e) {
    if (BuildConfig.DEBUG && !(e instanceof IOException)) {
      Log.w(LOGTAG,e);
    }
  }
}
