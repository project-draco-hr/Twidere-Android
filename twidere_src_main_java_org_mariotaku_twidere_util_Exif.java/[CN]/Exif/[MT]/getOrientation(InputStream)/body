{
  if (is == null)   return 0;
  final byte[] buf=new byte[8];
  int length=0;
  while (read(is,buf,2) && (buf[0] & 0xFF) == 0xFF) {
    final int marker=buf[1] & 0xFF;
    if (marker == 0xFF) {
      continue;
    }
    if (marker == 0xD8 || marker == 0x01) {
      continue;
    }
    if (marker == 0xD9 || marker == 0xDA)     return 0;
    if (!read(is,buf,2))     return 0;
    length=pack(buf,0,2,false);
    if (length < 2) {
      Log.e(TAG,"Invalid length");
      return 0;
    }
    length-=2;
    if (marker == 0xE1 && length >= 6) {
      if (!read(is,buf,6))       return 0;
      length-=6;
      if (pack(buf,0,4,false) == 0x45786966 && pack(buf,4,2,false) == 0) {
        break;
      }
    }
    try {
      is.skip(length);
    }
 catch (    final IOException ex) {
      return 0;
    }
    length=0;
  }
  if (length > 8) {
    int offset=0;
    final byte[] jpeg=new byte[length];
    if (!read(is,jpeg,length))     return 0;
    int tag=pack(jpeg,offset,4,false);
    if (tag != 0x49492A00 && tag != 0x4D4D002A) {
      Log.e(TAG,"Invalid byte order");
      return 0;
    }
    final boolean littleEndian=tag == 0x49492A00;
    int count=pack(jpeg,offset + 4,4,littleEndian) + 2;
    if (count < 10 || count > length) {
      Log.e(TAG,"Invalid offset");
      return 0;
    }
    offset+=count;
    length-=count;
    count=pack(jpeg,offset - 2,2,littleEndian);
    while (count-- > 0 && length >= 12) {
      tag=pack(jpeg,offset,2,littleEndian);
      if (tag == 0x0112) {
        final int orientation=pack(jpeg,offset + 8,2,littleEndian);
switch (orientation) {
case 1:
          return 0;
case 3:
        return 180;
case 6:
      return 90;
case 8:
    return 270;
}
Log.i(TAG,"Unsupported orientation");
return 0;
}
offset+=12;
length-=12;
}
}
Log.i(TAG,"Orientation not found");
return 0;
}
